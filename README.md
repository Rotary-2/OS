# MyOS – 32-bit Multitasking Kernel (x86)

> 从实模式启动到多任务调度的完整操作系统实现
> 15K+ 行代码 · 支持分页 · 用户态隔离 · 系统调用 · 简易文件系统

------

## 📌 项目概述

本项目基于 x86 架构，从 BIOS 启动阶段开始，实现一个支持：

- 保护模式切换
- 分页内存管理
- 内核态 / 用户态隔离
- 抢占式时间片调度
- fork 进程创建
- 简易文件系统
- 系统调用机制（int 0x80）

的 32 位操作系统原型。

> 目标：深入理解 CPU、内存管理、进程调度与中断机制的底层实现。

------

### ✅ CPU 架构理解

- 手动构建 GDT / IDT
- 配置 CR0 / CR3
- 开启分页机制
- 实现特权级切换（Ring0 → Ring3）
- TSS 支持任务切换

------

### ✅ 内存管理能力

- 物理内存位图管理
- 虚拟地址映射
- 页目录递归映射
- 内核堆 kmalloc 实现
- 用户空间独立页表

------

### ✅ 中断与系统调用

- 8259A 初始化
- 时钟中断驱动调度
- 键盘中断
- int 0x80 系统调用分发

------

### ✅ 进程与调度

- PCB 结构设计
- 双向链表调度队列
- 时间片轮转算法
- fork 实现
- 内核线程与用户进程统一管理

------

### ✅ 文件系统实现

- inode 结构
- 超级块
- 块位图管理
- 文件读写接口

------

## 🏗 系统架构图

模块划分：

```
Bootloader
   ↓
Memory Management
   ↓
Interrupt System
   ↓
Scheduler
   ↓
Filesystem
   ↓
User Process
```

------

## ⚙️ 开发环境

- 汇编：NASM
- C 编译器：GCC i386
- 调试工具：
  - **Bochs**
  - GDB

------

## 🚀 运行方式

```bash
make run
```

------

## 📊 项目规模

- 代码量：约 15,000 行
- 模块数：10+
- 系统调用：若干
- 支持多进程运行

------

## 🎯 项目收获

- 深入理解 CPU 特权级机制
- 掌握分页机制与地址转换
- 理解调度算法实现细节
- 明确“进程上下文切换”的本质

------

## 第二章  MBR主引导记录

#### 1.实模式下的1MB内存布局

内存映射表

![image-20260219212026459](G:\MyCode\OS\README.assets\image-20260219212026459.png)

#### 2.BIOS是如何苏醒的

![image-20260219212124265](G:\MyCode\OS\README.assets\image-20260219212124265.png)

**唤醒流程**：

1. 通电瞬间CPU强制设置CS:IP = 0xF000:0xFFF0
2. 执行0xFFFF0处的跳转指令
3. 跳转到0xFE05B开始执行真正的BIOS代码
4. BIOS进行硬件检测和初始化
5. 建立中断向量表(IVT)

#### 3.为什么是0x7c00历史原因：

早期PC最小内存32KB(0x8000)
MBR需要512字节+栈空间≈1KB
32KB末尾保留1KB：0x8000 - 0x400 = 0x7C00
BIOS约定加载MBR到此地址

#### 4.MBR代码功能说明：

清屏：使用BIOS中断0x10的06h号功能
获取光标：03h号功能获取当前光标位置
打印字符串：13h号功能在光标处打印
填充扇区：确保512字节大小，最后两个字节为0x55,0xaa

## 第三章 完善MBR

#### 1.CPU内部具有以下三个核心组件：

\- 控制单元：指令处理流程控制
\- 运算单元：算术逻辑运算执行
\- 存储单元：数据暂存和高速缓存

<img src="G:\MyCode\OS\README.assets\image-20260219212840026.png" alt="image-20260219212840026" style="zoom: 67%;" />

#### 2.分段机制产生原因：

\- 16位寄存器无法直接访问20位地址空间
\- 通过"段基址×16 + 偏移"实现1MB寻址
\- 解决8086之前地址硬编码问题

<img src="G:\MyCode\OS\README.assets\image-20260219213007302.png" alt="image-20260219213007302" style="zoom: 67%;" />

#### 3.栈的特点

\- 栈也是内存的一块存储数据的区域。
\- 后进先出(LIFO)数据结构，向下增长（高地址向低地址）。
\- 由SS:SP指定栈顶位置，即第一个可用的数据。

<img src="G:\MyCode\OS\README.assets\image-20260219213213953.png" alt="image-20260219213213953" style="zoom:67%;" />

#### 4.实模式特点

\- 通过分段机制寻址
\- 直接物理内存访问
\- 无内存保护机制
\- 1MB内存空间限制

#### 5.**常用调试命令**：

| 命令 | 功能    | 示例       |
| ---- | ------- | ---------- |
| `b   | break`  | 设置断点   |b 0x7c00|
| `c   | cont`   | 继续执行   |c|
| `s   | step`   | 单步步入   |s|
| `n   | next`   | 单步步过   |n|
| `r   | reg`    | 显示寄存器 |r、info eflags|
| `x   | xp`     | 查看内存   |xp  /512xb  0x7c00|
| `u   | disasm` | 反汇编     |u  /512  0x7c00|

#### 6.硬盘读写标准化流程

1. **设置扇区数**      → 端口 0x1F2
2. **设置LBA地址**  → 端口 0x1F3-0x1F6
3. **发送命令**         → 端口 0x1F7
4. **等待就绪**         → 检查端口 0x1F7 状态
5. **数据传输 **         → 端口 0x1F0

#### 7.MBR需要将磁盘上的程序复制到内存，将控制权交给loader，接下来改造MBR实现硬盘读取，让loader接力MBR

![image-20260219213732788](G:\MyCode\OS\README.assets\image-20260219213732788.png)

## 第四章  保护模式入门

#### 1.全局描述符表(GDT)

是保护模式的核心数据结构，用于管理内存段。

GDT为段描述符数组，由GDTR寄存器指向。选择子用于索引GDT中的描述符。

选择子结构：
\- 索引：13位，索引描述符。
\- TI位：0表示GDT，1表示LDT。LDT在以后再介绍。
\- RPL：请求特权级。

<img src="G:\MyCode\OS\README.assets\image-20260219214029443.png" alt="image-20260219214029443" style="zoom: 67%;" />

#### 2.段描述符

段描述符8字节，描述内存段的属性：
\- 段基址：32位。
\- 段界限：20位，粒度由G位决定（1字节或4KB）。
\- 属性字段：类型、特权级、存在位等。

<img src="G:\MyCode\OS\README.assets\image-20260219214235584.png" alt="image-20260219214235584" style="zoom: 67%;" />

#### 3.实现从实模式到保护模式切换的关键步骤：

1. 定义GDT和描述符。

2. 加载GDTR。

3. 打开A20。

4. 设置CR0.PE=1。

5. 远跳转刷新流水线。

#### 4.向段寄存器加载选择子时的保护

引用某段内存会往段寄存器加载选择子，CPU会进行检查：
\- 选择子索引值是否越界，***\*选择子中的索引值 \* 8 + 7 <= 描述符表基地址 + 描述符表界限值\****。
\- ***\*通过段描述符type字段\****，判断段类型是否匹配段寄存器。
\- 通过P位判断段是否位于内存，若P为1，表示在内存，更新段描述符缓冲寄存器和段寄存器，A位由CPU再置1，不是已访问。
                          若P位0，还需先将该段载入内存再处理。

![image-20260219214641496](G:\MyCode\OS\README.assets\image-20260219214641496.png)

5.**代码段和数据段的保护**

确保指令或数据完全在段界限内，段界限指向最后一个可以使用的字节：
\- 指令或数据偏移地址 + 长度 - 1 ≤ 段界限
\- ***\*举例\****：若实际段界限是 `0x12345FFF`，访问其最后1字节是合法的，但试图读取2字节（会用到下一个地址 `0x12346000`）就会因越界而触发异常。

![image-20260219214832606](G:\MyCode\OS\README.assets\image-20260219214832606.png)

#### 6.栈段的保护

向下扩展段的段界限意义不同,段界限指的是第一个不可使用的地址。

每次对栈进行操作前都会先进行预先的判断：实际段界限 + 1 ≤ ESP - 预备操作数大小 ≤ 0xFFFFFFFF

<img src="G:\MyCode\OS\README.assets\image-20260219214949665.png" alt="image-20260219214949665" style="zoom: 67%;" />

## 第五章  保护模式进阶

#### 1.内存为什么要分页

在分段机制下，内存分配需要连续空间，容易产生碎片。
根本原因在于：线性地址是连续的，物理地址也要是连续的。
***\*分页\****可使的线性地址连续，但是物理地址不连续：
分页机制将内存划分为固定大小的页，通过页表实现虚拟地址到物理地址的映射，解决内存碎片问题。

<img src="G:\MyCode\OS\README.assets\image-20260219215707225.png" alt="image-20260219215707225" style="zoom:67%;" />

![image-20260219215549639](G:\MyCode\OS\README.assets\image-20260219215549639.png)

#### 2.二级页表

![image-20260219215738112](G:\MyCode\OS\README.assets\image-20260219215738112.png)

| 位置 | 属性名称                   | 描述                                                         |
| ---- | -------------------------- | ------------------------------------------------------------ |
| 0    | P                          | 存在位：1表示存在于物理内存中；<br />0表示不在物理内存中，访问会触发缺页异常。 |
| 1    | (Read/Write)               | 读写位：1表示可读可写；0表示只读，写操作会触发异常。         |
| 2    | (User/Supervisor)          | 用户/超级用户位：1表示User级；0表示Supervisor级。            |
| 3    | (Page-level Write-Through) | 页级通写位：1表示采用通写方式（用于高速缓存）；<br />                        0表示采用回写方式。通常置0。 |
| 4    | (Page-level Cache Disable) | 页级高速缓存禁止位：1表示启用高速缓存；<br />                                       0表示禁止缓存该页。通常置0。 |
| 5    | (Accessed)                 | 访问位：1表示该页近期被CPU访问过（由CPU设置）；0表示未访问。操作系统可定期清0以统计使用频率。 |
| 6    | 保留                       | 在页目录项中保留无效<br />(脏页位D仅对页表项有效，PDE中此位无意义）。 |
| 7    | (Page Attribute Table)     | 页属性表位：用于在页面粒度设置内存属性。复杂，通常置0。      |
| 8    | (Global)                   | 全局位：1表示该页为全局页，在TLB中持久缓存；<br />                0表示非全局页。 |
| 9-11 | (Available)                | 可用位：共3位，供操作系统软件使用，CPU忽略其值。             |

#### 3.操作系统与用户进程的关系

操作系统和用户进程需要配合才能实现相应功能：
通过页表实现内存隔离和共享。
操作系统位于高地址空间(3GB-4GB)，用户进程位于低地址空间(0-3GB)。
为了实现共享操作系统，让所有用户进程高地址空间都指向同一片物理页内存，这片物理页上的是操作系统的实体代码，即页表项对应的物理地址相同。

#### 4.启用分页需要三个步骤：

1. 准备页目录表和页表
2. 将页目录表地址写入CR3寄存器
3. 设置CR0的PG位

![image-20260219215843850](G:\MyCode\OS\README.assets\image-20260219215843850.png)

#### 5.快表TLB

分页机制下虚拟地址转换需多次访问内存，效率低下。
TLB（Translation Lookaside Buffer）缓存虚拟地址到物理地址的转换结果，提高地址转换速度。

TLB特点：
\- 不自动更新：处理器将维护责任交给操作系统开发人员

\- 两种更新方法：重载CR3寄存器：使整个TLB失效

​                           使用`invlpg`指令：刷新特定虚拟地址对应的条目

#### 6.调用方调用流程：

读取文件头，获取程序尺寸和入口地址。
将程序体复制到入口地址对应的内存。
跳转到入口地址执行。

#### 7.将内核载入内存

内核是操作系统的核心，必须由Loader将其从硬盘加载至内存。
内核加载分两步：从硬盘读取内核二进制文件（kernel.bin）至内存缓冲区；再解析ELF文件结构，将程序段拷贝到正确的内存地址。
关键数据：内核缓冲区：   0x70000
		  内核入口地址：0xc0001500   
		  内核栈指针：   0xc009f000  

![image-20260219220511353](G:\MyCode\OS\README.assets\image-20260219220511353.png)

8.特权级

特权级是保护模式的基石，隔离系统与用户程序。特权检查发生在访问资源时(如内存、IO)，由CPU自动完成。数据段强调**绝对保护**，代码段强调**可控共享**。

**CPL**表示**当前正在执行的代码所处的特权级别**，存储在CS寄存器的最低两位。

**DPL**定义在**段描述符中**，规定了访问该段所需的最低特权级别。

**RPL**是**选择子（Selector）中的特权级字段**，代表的是"请求发起者"的特权级。

**关键点**：***0级***：操作系统内核，直接控制硬件。
	      ***3级***：用户程序，权限受限，需通过系统调用访问核心资源。

​              这种设计确保低特权代码无法越权访问高特权资源，提升系统稳定性。

![image-20260219220553668](G:\MyCode\OS\README.assets\image-20260219220553668.png)









































































































## 第九章  线程

#### 4.通用异常处理函数是如何实现的？

该函数是一个通用中断/异常处理函数，用于处理未单独实现的异常。
它首先过滤 8259A 产生的 IRQ7 和 IRQ15 伪中断。
然后清空屏幕左上角区域，打印异常开始标志和异常名称。
如果异常为 Page Fault 缺页中断（向量号 14），则通过读取 CR2 寄存器获取导致缺页的线性地址并打印。
最后进入死循环，使系统停机，方便调试。
该函数通常作为 IDT 的默认异常入口函数。

#### 5.时钟中断处理函数是如何实现的？

该函数是时钟中断处理函数，由硬件定时器周期性触发。
它首先获取当前运行线程PCB，检查内核栈魔数防止栈溢出。
然后更新当前线程的运行时间和系统全局 tick 计数。
若当前线程时间片耗尽，则调用 schedule 进行进程调度；否则将时间片减一。
该机制实现了基于时间片的抢占式调度。

#### 6.如何获取当前线程pcb指针？

通过读取 ESP 寄存器获取当前内核栈地址。
由于每个线程的 PCB 和内核栈共用一个 4KB 页，并且 PCB 位于页的低地址处，因此将 ESP 与 0xFFFFF000 进行按位与运算，得到页起始地址，即当前线程的 PCB 地址。

#### 7.把内核主线程(main)纳入线程管理体系是如何实现的？为什么需要这个函数？

原因：
在内核启动时CPU 早已在执行 main：
	但此时还没有线程管理结构
	main 只是普通执行流
为了实现统一调度：
	必须把 main 包装成一个线程（PCB）

该函数用于将内核启动阶段已经执行的 main 函数封装为线程控制块。
由于 main 线程的 PCB 和内核栈在 loader 阶段已经预留，因此无需重新分配内存。
函数通过 running_thread 获取当前 PCB，并调用 init_thread 进行初始化。
最后将其加入所有线程链表 thread_all_list，但不加入就绪队列，因为当前线程正在运行。
该设计保证了 main 线程可以统一纳入线程调度管理体系。

#### 8.如何设计线程切换的底层实现？

switch_to 函数用于完成线程上下文切换。
它首先保存当前线程的通用寄存器，并将当前 ESP 保存到当前线程 PCB 的 self_kstack 字段中。
然后加载下一个线程的 self_kstack 到 ESP，从而切换到下一个线程的内核栈。
随后恢复寄存器并执行 ret 指令，跳转到下一个线程之前保存的执行位置。
该函数本质通过切换栈指针实现线程切换。

## 第十章  输入输出系统

#### 1.分析字符打印混乱和GP异常问题

1. 现象：
   字符串打印时字符丢失。
   输出中出现大片空缺。
   发生 **GP 异常**，由寄存器 `bx` 值超出显存段引起。

2. 根本原因
   临界区代码未实现互斥访问。
   字符打印函数 `put_char` 包含三个步骤：
   1）**获取** 光标值
   2）将光标值转换为显存地址并 **写入** 字符
   3）**更新** 光标值
   这三个步骤必须 **原子性执行**。
   但任务调度可能在执行过程中被打断，导致多个线程：
   1）覆盖显存
   2）设置错误的光标值
   3）破坏显卡寄存器状态

3. 临时解决方案
   在 `put_str` 前后关闭中断：

```c
intr_disable();
/* put_str */
intr_enable();
```

通过禁止中断，强制保证临界区代码原子执行。

4. GP 异常分析（获取 → 写入 → 更新）
   线程 A 执行过程：已打印字符（`0x7ce`），进入更新阶段，准备将光标更新为 `0x7cf`（屏幕右下角），仅写入高 8 位（`0x7`）后发生中断，切换到线程 B(此时光标寄存器仍为 `0x7ce`)。
   线程 B 执行过程：读取光标 `0x7ce`，输出字符，光标变为 `0x7cf`，触发滚屏。准备更新光标时，已向显卡发出“写高 8 位”信号，时间片耗尽，中断，切换回线程 A。
   线程 A 继续执行：继续写入低 8 位 `0xcf`，但显卡由于前序控制信号状态错乱，将该值误判为“高 8 位”，最终光标寄存器变为0xcfcf。

#### 2.线程的阻塞与唤醒机制是如何实现的

thread_block 用于当前线程主动阻塞，它会关闭中断，修改线程状态为 BLOCKED、WAITING或HANGING，并调用 schedule 切换线程；
thread_unblock 用于唤醒阻塞线程，它会将线程状态改为 READY 并插入就绪队列。
两者都在关中断环境下操作 ready_list，以保证原子性和避免竞态条件。

#### 3.信号量的 P/V 操作（down/up）实现原理

sema_down 是信号量的 P 操作，当资源不可用时会将当前线程加入等待队列并阻塞；
sema_up 是 V 操作，用于释放资源并唤醒一个等待线程。
整个过程通过关中断保证原子性，采用 while 循环防止虚假唤醒，是基于阻塞队列实现的线程同步机制。

#### 4.基于信号量实现的可重入锁（递归锁）机制是如何实现的？

该代码实现了一个基于信号量的可重入互斥锁。
lock_acquire 通过 sema_down 获取资源，并记录锁的持有者和重入次数；
若同一线程重复加锁，仅增加计数而不阻塞；
lock_release 通过减少重入计数，在最后一次释放时调用 sema_up 唤醒等待线程。
本质是“二值信号量 + 持有者记录 + 重入计数”实现的递归锁。
