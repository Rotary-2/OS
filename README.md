# MyOS – 32-bit Multitasking Kernel (x86)

> 从实模式启动到多任务调度的完整操作系统实现
> 15K+ 行代码 · 支持分页 · 用户态隔离 · 系统调用 · 简易文件系统

------

## 📌 项目概述

本项目基于 x86 架构，从 BIOS 启动阶段开始，实现一个支持：

- 保护模式切换
- 分页内存管理
- 内核态 / 用户态隔离
- 抢占式时间片调度
- fork 进程创建
- 简易文件系统
- 系统调用机制（int 0x80）

的 32 位操作系统原型。

> 目标：深入理解 CPU、内存管理、进程调度与中断机制的底层实现。

------

### ✅ CPU 架构理解

- 手动构建 GDT / IDT
- 配置 CR0 / CR3
- 开启分页机制
- 实现特权级切换（Ring0 → Ring3）
- TSS 支持任务切换

------

### ✅ 内存管理能力

- 物理内存位图管理
- 虚拟地址映射
- 页目录递归映射
- 内核堆 kmalloc 实现
- 用户空间独立页表

------

### ✅ 中断与系统调用

- 8259A 初始化
- 时钟中断驱动调度
- 键盘中断
- int 0x80 系统调用分发

------

### ✅ 进程与调度

- PCB 结构设计
- 双向链表调度队列
- 时间片轮转算法
- fork 实现
- 内核线程与用户进程统一管理

------

### ✅ 文件系统实现

- inode 结构
- 超级块
- 块位图管理
- 文件读写接口

------

## 🏗 系统架构图

模块划分：

```
Bootloader
   ↓
Memory Management
   ↓
Interrupt System
   ↓
Scheduler
   ↓
Filesystem
   ↓
User Process
```

------

## ⚙️ 开发环境

- 汇编：NASM
- C 编译器：GCC i386
- 调试工具：
  - **Bochs**
  - GDB

------

## 🚀 运行方式

```bash
make run
```

------

## 📊 项目规模

- 代码量：约 15,000 行
- 模块数：10+
- 系统调用：若干
- 支持多进程运行

------

## 🎯 项目收获

- 深入理解 CPU 特权级机制
- 掌握分页机制与地址转换
- 理解调度算法实现细节
- 明确“进程上下文切换”的本质

------

## 第九章  线程

#### 4.通用异常处理函数是如何实现的？

该函数是一个通用中断/异常处理函数，用于处理未单独实现的异常。
它首先过滤 8259A 产生的 IRQ7 和 IRQ15 伪中断。
然后清空屏幕左上角区域，打印异常开始标志和异常名称。
如果异常为 Page Fault 缺页中断（向量号 14），则通过读取 CR2 寄存器获取导致缺页的线性地址并打印。
最后进入死循环，使系统停机，方便调试。
该函数通常作为 IDT 的默认异常入口函数。

#### 5.时钟中断处理函数是如何实现的？

该函数是时钟中断处理函数，由硬件定时器周期性触发。
它首先获取当前运行线程PCB，检查内核栈魔数防止栈溢出。
然后更新当前线程的运行时间和系统全局 tick 计数。
若当前线程时间片耗尽，则调用 schedule 进行进程调度；否则将时间片减一。
该机制实现了基于时间片的抢占式调度。

#### 6.如何获取当前线程pcb指针？

通过读取 ESP 寄存器获取当前内核栈地址。
由于每个线程的 PCB 和内核栈共用一个 4KB 页，并且 PCB 位于页的低地址处，因此将 ESP 与 0xFFFFF000 进行按位与运算，得到页起始地址，即当前线程的 PCB 地址。

#### 7.把内核主线程(main)纳入线程管理体系是如何实现的？为什么需要这个函数？

原因：
在内核启动时CPU 早已在执行 main：
	但此时还没有线程管理结构
	main 只是普通执行流
为了实现统一调度：
	必须把 main 包装成一个线程（PCB）

该函数用于将内核启动阶段已经执行的 main 函数封装为线程控制块。
由于 main 线程的 PCB 和内核栈在 loader 阶段已经预留，因此无需重新分配内存。
函数通过 running_thread 获取当前 PCB，并调用 init_thread 进行初始化。
最后将其加入所有线程链表 thread_all_list，但不加入就绪队列，因为当前线程正在运行。
该设计保证了 main 线程可以统一纳入线程调度管理体系。

#### 8.如何设计线程切换的底层实现？

switch_to 函数用于完成线程上下文切换。
它首先保存当前线程的通用寄存器，并将当前 ESP 保存到当前线程 PCB 的 self_kstack 字段中。
然后加载下一个线程的 self_kstack 到 ESP，从而切换到下一个线程的内核栈。
随后恢复寄存器并执行 ret 指令，跳转到下一个线程之前保存的执行位置。
该函数本质通过切换栈指针实现线程切换。

## 第十章  输入输出系统

#### 1.分析字符打印混乱和GP异常问题

1. 现象：
   字符串打印时字符丢失。
   输出中出现大片空缺。
   发生 **GP 异常**，由寄存器 `bx` 值超出显存段引起。

2. 根本原因
   临界区代码未实现互斥访问。
   字符打印函数 `put_char` 包含三个步骤：
   1）**获取** 光标值
   2）将光标值转换为显存地址并 **写入** 字符
   3）**更新** 光标值
   这三个步骤必须 **原子性执行**。
   但任务调度可能在执行过程中被打断，导致多个线程：
   1）覆盖显存
   2）设置错误的光标值
   3）破坏显卡寄存器状态

3. 临时解决方案
   在 `put_str` 前后关闭中断：

```c
intr_disable();
/* put_str */
intr_enable();
```

通过禁止中断，强制保证临界区代码原子执行。

4. GP 异常分析（获取 → 写入 → 更新）
   线程 A 执行过程：已打印字符（`0x7ce`），进入更新阶段，准备将光标更新为 `0x7cf`（屏幕右下角），仅写入高 8 位（`0x7`）后发生中断，切换到线程 B(此时光标寄存器仍为 `0x7ce`)。
   线程 B 执行过程：读取光标 `0x7ce`，输出字符，光标变为 `0x7cf`，触发滚屏。准备更新光标时，已向显卡发出“写高 8 位”信号，时间片耗尽，中断，切换回线程 A。
   线程 A 继续执行：继续写入低 8 位 `0xcf`，但显卡由于前序控制信号状态错乱，将该值误判为“高 8 位”，最终光标寄存器变为0xcfcf。

#### 2.线程的阻塞与唤醒机制是如何实现的

thread_block 用于当前线程主动阻塞，它会关闭中断，修改线程状态为 BLOCKED、WAITING或HANGING，并调用 schedule 切换线程；
thread_unblock 用于唤醒阻塞线程，它会将线程状态改为 READY 并插入就绪队列。
两者都在关中断环境下操作 ready_list，以保证原子性和避免竞态条件。
